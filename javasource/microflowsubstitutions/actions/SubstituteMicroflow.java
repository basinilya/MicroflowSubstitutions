// This file was generated by Mendix Studio Pro.
//
// WARNING: Only the following code will be retained when actions are regenerated:
// - the import list
// - the code between BEGIN USER CODE and END USER CODE
// - the code between BEGIN EXTRA CODE and END EXTRA CODE
// Other code you write will be lost the next time you deploy the project.
// Special characters, e.g., é, ö, à, etc. are supported in comments.

package microflowsubstitutions.actions;

import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Vector;
import java.util.concurrent.ConcurrentHashMap;
import java.util.function.Supplier;

import com.mendix.core.Core;
import com.mendix.core.actionmanagement.ListenersRegistry;
import com.mendix.core.actionmanagement.MicroflowCallBuilder;
import com.mendix.logging.ILogNode;
import com.mendix.systemwideinterfaces.core.IContext;
import com.mendix.systemwideinterfaces.core.ICoreAction;
import com.mendix.systemwideinterfaces.core.UserAction;
import com.mendix.systemwideinterfaces.core.UserActionListener;
import com.mendix.webui.CustomJavaAction;

/**
 * Substitute original microflow with another microflow. The parameter names must match exactly and the parameters types and the return type must be compatible.
 */
public class SubstituteMicroflow extends CustomJavaAction<java.lang.Void>
{
	private final java.lang.String original;
	private final java.lang.String substitute;

	public SubstituteMicroflow(final IContext context, final java.lang.String original, final java.lang.String substitute)
	{
		super(context);
		this.original = original;
		this.substitute = substitute;
	}

	@java.lang.Override
	public java.lang.Void executeAction() throws Exception
	{
		// BEGIN USER CODE
        final MicroflowActionHook instance = MicroflowActionHook.INSTANCE;
        final String prev =
            instance.substitutionsByOriginalNames
            .put(Objects.requireNonNull(original), substitute);
        if (prev != null) {
            instance.originalsBySubstitutionNames.remove(prev);
        }
        if (substitute != null) {
            instance.originalsBySubstitutionNames.put(substitute, original);
        }
        return null;
		// END USER CODE
	}

	/**
	 * Returns a string representation of this action
	 */
	@java.lang.Override
	public java.lang.String toString()
	{
		return "SubstituteMicroflow";
	}

	// BEGIN EXTRA CODE

    /**
     * Replace Event Action that calls the desired microflow. With addReplaceEvent() a microflow
     * action can't be directly replaced with another microflow action, only with a java action.
     */
    public static class SubstituteMicroflowCallbackAction
        extends CustomJavaAction<java.lang.Object> {

        /**
         * Source of parameters for this action. For a microflow action 8x can only construct
         * Replace Event Actions with zero args.
         */
        static final ThreadLocal<MicroflowCallBuilderWrapper> PARAMS_TLS = new ThreadLocal<>();

        /** parameters for this action */
        private final MicroflowCallBuilderWrapper builderWr;

        /**
         * One and only constructor. 8x just invokes a random declared constructor and passes zero
         * args
         */
        public SubstituteMicroflowCallbackAction() {
            super(PARAMS_TLS.get().context);
            this.builderWr = PARAMS_TLS.get();
        }

        @java.lang.Override
        public java.lang.Object executeAction() throws Exception {
            return builderWr.builderSupplier.get().execute(builderWr.context);
        }

        @java.lang.Override
        public java.lang.String toString() {
            return this.getClass().getSimpleName();
        }
    }

    /** Parameters for SubstituteMicroflowCallbackAction */
    private static class MicroflowCallBuilderWrapper {

        /** Context of the original microflow */
        final IContext context;

        /**
         * Supplier of the microflow builder. A delayed construction of the builder is needed
         * because check() is called twice
         */
        final Supplier<MicroflowCallBuilder> builderSupplier;

        private MicroflowCallBuilderWrapper(
                final IContext context,
                final Supplier<MicroflowCallBuilder> builderSupplier) {
            this.context = context;
            this.builderSupplier = builderSupplier;
        }
    }

    /** Action Listener that can substitute a microflow to call */
    private static class MicroflowActionHook extends UserActionListener<UserAction<?>> {

        private static final ILogNode LOGGER = Core.getLogger("AAAMicroflowSubstitutions");

        // various reflect classes, methods, and fields to obtain
        // the information about the called microflow

        private static final ClassLoader MX_RUNTIME_CLASSLOADER = getMxRuntimeClassLoader();

        @SuppressWarnings("unchecked")
        private static final Class<UserAction<?>> C_MicroflowImpl =
            (Class<UserAction<?>>) getMxRuntimeClass(
                "com.mendix.modules.microflowengine.microflow.impl.MicroflowImpl");

        private static final Class<?> C_MicroflowStructure =
            getMxRuntimeClass(
                "com.mendix.modules.microflowengine.microflowstructure.MicroflowStructure");

        private static final Class<?> C_SCALA_Seq = getMxRuntimeClass("scala.collection.Seq");

        private static final Class<?> C_SCALA_Map = getMxRuntimeClass("scala.collection.Map");

        private static final Class<?> C_JavaConverters =
            getMxRuntimeClass("scala.collection.JavaConverters");

        private static final Class<?> C_Scope =
            getMxRuntimeClass("com.mendix.modules.microflowengine.microflow.Scope");

        private static final Class<?> C_MendixValue =
            getMxRuntimeClass("com.mendix.basis.value.MendixValue");

        private static final Class<?> C_MicroflowStructureInputParameter =
            getMxRuntimeClass(
                "com.mendix.modules.microflowengine.microflowstructure.MicroflowStructureInputParameter");

        private static final Field F_executeInTransaction =
            getField(C_MicroflowImpl, boolean.class, "executeInTransaction");

        private static final Method M_getStructure =
            getPublicMethod(C_MicroflowImpl, C_MicroflowStructure, "getStructure");

        private static final Method M_getScope =
            findPublicMethod(C_MicroflowImpl, C_Scope, "getScope");

        // 9x, <MicroflowStructureInputParameter>
        private static final Method M_inputParameters =
            findPublicMethod(C_MicroflowStructure, C_SCALA_Seq, "inputParameters");

        // 8x, <MicroflowStructureInputParameter>
        private static final Method M_getInputParameters =
            M_inputParameters != null
                ? null
                : getPublicMethod(C_MicroflowStructure, List.class, "getInputParameters");

        // <String, MendixValue>
        private static final Method M_getVariables =
            getPublicMethod(C_Scope, C_SCALA_Map, "getVariables");

        private static final Method C_MendixValue__get =
            getPublicMethod(C_MendixValue, Object.class, "get");

        private static final Method M_asJava_Seq =
            getPublicMethod(C_JavaConverters, List.class, "asJava", C_SCALA_Seq);

        private static final Method M_asJava_Map =
            getPublicMethod(C_JavaConverters, Map.class, "asJava", C_SCALA_Map);

        private static final Method M_MicroflowStructureInputParameter_getName =
            get_MicroflowStructureInputParameter_getName();

        /** One and only instance of this Action Listener */
        static final MicroflowActionHook INSTANCE = createAndRegisterListener();

        /** Map of microflow names to substitute */
        final Map<String, String> substitutionsByOriginalNames = new ConcurrentHashMap<>();

        final Map<String, String> originalsBySubstitutionNames = new ConcurrentHashMap<>();

        private MicroflowActionHook() {
            super(C_MicroflowImpl);
            // With addReplaceEvent() a microflow action can't be directly replaced with
            // another microflow action, only with a java action.
            addReplaceEvent(SubstituteMicroflowCallbackAction.class.getName());
        }

        /**
         * Checks if this Listener's events must be fired
         * 
         * @return true if the action added with addReplaceEvent() should be executed instead of the
         *         original microflow
         */
        @Override
        public boolean check(final UserAction<?> currentAction) {
            final String microflowNameCallerPassed = currentAction.getActionName();
            LOGGER.info("checking microflow: " + microflowNameCallerPassed);
            String actualMicroflowToCall = substitutionsByOriginalNames.get(microflowNameCallerPassed);
            if (actualMicroflowToCall == null) {
                actualMicroflowToCall = originalsBySubstitutionNames.get(microflowNameCallerPassed);
            }

            if (actualMicroflowToCall == null || //
                isDirectCallByOurJavaAction(currentAction, microflowNameCallerPassed)) {
                // continue without overriding the action
                LOGGER.info("continue without overriding the action: " + microflowNameCallerPassed);
                return false;
            }

            final String actualMicroflowToCall2 = actualMicroflowToCall;
            SubstituteMicroflowCallbackAction.PARAMS_TLS
                .set(
                    new MicroflowCallBuilderWrapper(
                        currentAction.getContext(),
                        () -> createMicroflowCallBuilder(currentAction, actualMicroflowToCall2)));
            // override the action
            LOGGER
                .info(
                    "will call " + actualMicroflowToCall2 + " instead of "
                        + microflowNameCallerPassed);
            return true;
        }

        private boolean isDirectCallByOurJavaAction(
                final UserAction<?> currentAction,
                final String microflowNameCallerPassed) {
            LOGGER
                .info(
                    "Checking if microflow is called directly by our Java Action: "
                        + microflowNameCallerPassed);
            final IContext context = currentAction.getContext();
            final Vector<? extends ICoreAction<?>> /* NOSONAR */ actionStack =
                context.getActionStack();
            synchronized (actionStack) {
                "".toString();
                // check() is called twice. When Direct Call By Our Java Action,
                // first time stack:
                // SubstituteMicroflowCallbackAction
                // ...
                //
                // second time stack:
                // com.mendix.basis.actionmanagement.SyncEventExtendedAction
                // SubstituteMicroflowCallbackAction
                // ...

                for (
                    int rIndex = actionStack.size() - 1, minRIndex = Math.max(rIndex, 0);
                    rIndex >= minRIndex;
                    rIndex--) {
                    final ICoreAction<?> action = actionStack.get(rIndex);
                    final Class<?> actionClass = action.getClass();
                    if (SubstituteMicroflowCallbackAction.class.isAssignableFrom(actionClass)) {
                        LOGGER
                            .info(
                                "Microflow is called directly by our Java Action: "
                                    + microflowNameCallerPassed);
                        return true;
                    }
                }
            }
            LOGGER
                .info(
                    "Microflow is not called directly by our Java Action: "
                        + microflowNameCallerPassed);
            return false;
        }

        /**
         * Register the Replace Event Action, then create and register the listener
         */
        private static MicroflowActionHook createAndRegisterListener() {
            // Mendix can only instantiate registered java actions because
            // they're stored by special key, not by class name
            Core.addUserAction(SubstituteMicroflowCallbackAction.class);
            final MicroflowActionHook res = new MicroflowActionHook();
            final ListenersRegistry reg = Core.getListenersRegistry();
            reg.addListener(res);
            return res;
        }

        /**
         * Create Microflow Call Builder
         */
        private static MicroflowCallBuilder createMicroflowCallBuilder(
                final UserAction<?> action,
                final String substitute) {
            return Core
                .microflowCall(substitute)
                .inTransaction(isExecuteInTransaction(action))
                .withParams(getParameterValues(action))
            // 9x+ task queue additions .with*Retry() aren't needed
            ;
        }

        /**
         * @return true if the original microflow was built with inTransaction(true)
         */
        private static boolean isExecuteInTransaction(final UserAction<?> action) {
            try {
                return (boolean) F_executeInTransaction.get(action);
            } catch (final IllegalAccessException e) {
                throw new RuntimeException(e);
            }
        }

        /**
         * @return map of original microflow parameter values
         */
        @SuppressWarnings("unchecked")
        private static Map<String, Object> getParameterValues(final UserAction<?> action) {

            try {
                final Map<String, Object> result = new HashMap<>();

                final Object structure = M_getStructure.invoke(action);

                final List<?> inputParameters;

                if (M_inputParameters != null) {
                    final Object scalaList = M_inputParameters.invoke(structure);
                    inputParameters = (List<?>) M_asJava_Seq.invoke(null, scalaList);
                } else {
                    inputParameters = (List<?>) M_getInputParameters.invoke(structure);
                }

                final Object scope = M_getScope.invoke(action);
                final Object scalaMap = M_getVariables.invoke(scope);
                final Map<String, ?> variables =
                    (Map<String, ?>) M_asJava_Map.invoke(null, scalaMap);
                for (final Object inputParameter : inputParameters) {
                    final String name =
                        (String) M_MicroflowStructureInputParameter_getName.invoke(inputParameter);
                    final Object mendixValue = variables.get(name);
                    final Object value = C_MendixValue__get.invoke(mendixValue);
                    result.put(name, value);
                }
                return result;
            } catch (IllegalAccessException | InvocationTargetException e) {
                throw new RuntimeException(e);
            }
        }

        // various utilities to initialize the reflect fields above

        private static ClassLoader getMxRuntimeClassLoader() {
            // the class that implements Configuration is in Mx Runtime
            return Core.getConfiguration().getClass().getClassLoader();
        }

        private static Class<?> getMxRuntimeClass(final String className) {
            try {
                final boolean initialize = true;
                return Class.forName(className, initialize, MX_RUNTIME_CLASSLOADER);
            } catch (final ClassNotFoundException e) {
                throw new RuntimeException(e);
            }
        }

        private static Method get_MicroflowStructureInputParameter_getName() {
            // 9x+
            final Method tmp =
                findPublicMethod(C_MicroflowStructureInputParameter, String.class, "name");
            // 8x fallback
            return tmp != null
                ? tmp
                : getPublicMethod(C_MicroflowStructureInputParameter, String.class, "getName");
        }

        private static Field getField(
                final Class<?> clazz,
                final Class<?> expectType,
                final String fieldName) {
            try {
                final Field field = clazz.getDeclaredField(fieldName);
                if (!field.getType().isAssignableFrom(expectType)) {
                    throw new RuntimeException(
                        "Field expected to have type " + expectType.getName()
                            + " but its signature is: " + field.toString());
                }
                field.setAccessible(true);
                return field;
            } catch (final NoSuchFieldException e) {
                throw new RuntimeException(e);
            }
        }

        private static Method getPublicMethod(
                final Class<?> clazz,
                final Class<?> expectReturn,
                final String name,
                final Class<?>... parameterTypes) {
            try {
                return getPublicMethod0(true, clazz, expectReturn, name, parameterTypes);
            } catch (final NoSuchMethodException e) {
                throw new RuntimeException(e);
            }
        }

        private static Method findPublicMethod(
                final Class<?> clazz,
                final Class<?> expectReturn,
                final String name,
                final Class<?>... parameterTypes) {
            try {
                return getPublicMethod0(false, clazz, expectReturn, name, parameterTypes);
            } catch (final NoSuchMethodException e) {
                return null;
            }
        }

        private static Method getPublicMethod0(
                final boolean throwExpectReturn,
                final Class<?> clazz,
                final Class<?> expectReturn,
                final String name,
                final Class<?>... parameterTypes) throws NoSuchMethodException {
            final Method method = clazz.getMethod(name, parameterTypes);
            if (!expectReturn.isAssignableFrom(method.getReturnType())) {
                if (throwExpectReturn) {
                    throw new RuntimeException(
                        "Method expected to return " + expectReturn.getName()
                            + " but its signature is: " + method.toString());
                }
                return null;
            }
            return method;
        }
    }
	// END EXTRA CODE
}
